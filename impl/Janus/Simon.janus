
/* Rotate 'x' by 'r' bits to the left */
procedure rotate_left_u32(u32 x, int r)
    local int rm = r % 32
    local int rmc = 32 - rm
    local u32 y = (x << rm) | (x >> rmc)
    x <=> y
    delocal u32 y = (x >> rm) | (x << rmc)
    delocal int rmc = 32 - rm
    delocal int rm = r % 32

/* z0 = 4506230155203752166
 * z1 = 2575579794259089498
 * z2 = 3160415496042964403
 * z3 = 3957284701066611983
 * z4 = 3781244162168104175
 */

procedure get_tmp(u32 k, int m, u32 tmp)
    local u32 tmp2 = 0
    tmp += key_expanded[i-1]
    uncall rotate_left_u32(tmp, 3)
    if m = 4 then
        tmp ^= k[i-3]
    fi m = 4
    tmp2 += tmp
    uncall rotate_left_u32(tmp2, 1)
    tmp ^= tmp2
    call rotate_left_u32(tmp2, 1)
    delocal u32 tmp2 = tmp

procedure get_bit(int j, int i, int bit)
    local u32 z[5] = {0b11111010001001010110000111001101111101000100101011000011100110,
                      0b10001110111110010011000010110101000111011111001001100001011010,
                      0b10101111011100000011010010011000101000010001111110010110110011,
                      0b11011011101011000110010111100000010010001010011100110100001111,
                      0b11010001111001101011011000100000010111000011001010010011101111}
    local u32 tmp 
    if z[j] & (1 << (32 - i)) != 0 then
        bit += 1
    fi z[j] & (1 << (32 - i)) != 0
    delocal u32 z[5] = {0b11111010001001010110000111001101111101000100101011000011100110,
                        0b10001110111110010011000010110101000111011111001001100001011010,
                        0b10101111011100000011010010011000101000010001111110010110110011,
                        0b11011011101011000110010111100000010010001010011100110100001111,
                        0b11010001111001101011011000100000010111000011001010010011101111}

procedure Simon_key_expansion(u32 key[], u32 key_expanded[], int rounds)
    local int m = size(key)
    local u32 tmp = 0
    local int i = 0
    local u32 bit = 0
    from i = 0 loop
        key_expanded[i] += key[i]
    until i = m
    from i = m loop
        call get_tmp(key_expanded[i-1], m, tmp)
        call get_bit(j, i-m % 62, bit)
        //k[i] += ~k[i-m] ^ tmp ^ z[j][i-m % 62] ^ 3
        k[i] += ~k[i-m] ^ tmp ^ bit ^ 3
        uncall get_bit(j, i-m % 62, bit)
        uncall get_tmp(key_expanded[i-1], m, tmp)
        i += 1
    until i = round
    delocal u32 bit = 0
    delocal int i = rounds
    delocal u32 tmp = 0
    delocal int m = size(key)

// we don't want to employ Benett's trick, I think that's counterproductive in our case (for cryptoanalysis)
//procedure Simon_round(int S1, int S2, int S8, 

procedure Simon_encipher(u32 data[2], u32 key[], int rounds)
    local u32 key_expanded[rounds]
	local int i = 0
    local u32 x1 = 0 //these variables are a nightmare to get rid of
    local u32 x2 = 0
    local u32 x8 = 0
    call Simon_key_expansion(key, key_expanded)
    from i = 0 loop
        x1 += data[0]
        call rotate_left_u32(x1, 1)
        x2 += data[0]
        call rotate_left_u32(x2, 2)
        x8 += data[0]
        call rotate_left_u32(x8, 8)
        /* The AND operation is lossful, i.e. it cannot be reversed without knowing all of its original operands.
         * Therefore, both x1 and x8 cannot be cleared just by using the rest of the variables used on the line below.
         * I need to think about this more.
         *   - that would imply decryption is impossible. The trick is we don't overwrite x, we keep it for the next round.
         * 
         * From the inverse round function from the specs:
         * R(x, y)    = (y ^ f(x) ^ k, x)
         * R^-1(x, y) = (y, x ^ f(x) ^ k)
         * (x,y) = R^-1(R(x,y)) = R^-1(y ^ f(x) ^ k, x) = (x, y ^ f(x) ^ k ^ f(x) ^ k)) = (x,y)
         */
        // R(x, y) = (y ^ f(x) ^ k, x)
        data[1] ^= (x1 & x8) ^ x2 ^ key_expanded[i]
        data[0] <=> data[1]
        //x2 -= data[0] ^ (x1 & x8) ^ key_expanded[i]
        // R^-1(x, y) = (y, x ^ f(x) ^ k)
        rx += data[1]
        //ry += data[0] ^ () ^ key_expanded[i]
        call rotate_left_u32(rx, 1)
        x1 -= rx
        call rotate_left_u32(rx, 2)
        x2 -= rx
        call rotate_left_u32(rx, 8)
        x8 -= rx
        rx -= data[1]
        i += 1
    until i = rounds
    uncall Simon_key_expansion(key, key_expanded)
    delocal u32 x8 = 0
    delocal u32 x2 = 0
    delocal u32 x1 = 0
    delocal int i = rounds
    delocal u32 key_expanded[rounds]


procedure main()
    u32 key[4]
    u32 data[2]
    u32 more_data[4]
    int num_rounds

    key[0] += 0
    key[1] += 1
    key[2] += 2
    key[3] += 3
    
    data[0] += 42
    data[1] += 27
    
    more_data[0] += 42
    more_data[1] += 27
    more_data[2] += 42
    more_data[3] += 27
    
    num_rounds += 32
    
    show(data)
    call Simon_encipher(data, key, num_rounds)
    show(data)
    uncall Simon_encipher(data, key, num_rounds)
    show(data)
