
procedure rotate_left(int x, int r)
    local int rm = r % 32
    local int bits_hi = (2 ** rm) - 1
    local int bits_lo = (2 ** (32 - rm)) - 1
    local int temp_hi = x & (bits_hi * (2 ** (32 - rm)))
    local int temp_lo = x & bits_lo
    x ^= (temp_hi | temp_lo) ^ ((temp_hi / (2 ** (32 - rm))) | (temp_lo * (2 ** rm)))
    delocal int temp_lo = (x & (bits_lo * (2 ** rm))) / (2 ** rm)
    delocal int temp_hi = (x & bits_hi) * (2 ** (32 - rm))
    delocal int bits_lo = (2 ** (32 - rm)) - 1
    delocal int bits_hi = (2 ** rm) - 1
    delocal int rm = r % 32

procedure Speck_key_secondary_sequence(int key[], int l[], int rounds)
    local int m = size(key)
    local int i = 0
    l[0] += key[1]
    if m > 2 then
        l[1] += key[2]
        if m > 3 then
            l[2] += key[3]
        fi m > 3
    fi m > 2
    from i = 0 loop
        uncall rotate_left(l[i], 8)
        l[i+m-1] += (k[i] + l[i]) ^ i
        call rotate_left(l[i], 8)
    until i = (rounds - 1)
    delocal int i = (rounds - 1)
    delocal int m = size(key)

procedure Speck_key_expansion(int key[], int key_expanded[], int rounds)
    local int m = size(key)
    local int i = 0
    local int l[m+rounds]
    key_expanded[0] += key[0]
    call Speck_key_secondary_sequence(key, l, rounds)
    from i = 0 loop
        //todo: this with the secondary sequence generation can be replaced with a generic round function, the same as in encryption
        call rotate_left(key_expanded[i], 3)
        key_expanded[i+1] += key_expanded[i] ^ l[i+m-1]
        uncall rotate_left(key_expanded[i], 3)
        i += 1
    until i = (rounds - 1)
    uncall Speck_key_secondary_sequence(key, l, rounds)
    delocal int l
    delocal int i = 0
    delocal int m = size(key)
    

// we don't want to employ Benett's trick, I think that's counterproductive in our case (for cryptoanalysis)
//procedure Simon_round(int S1, int S2, int S8, 

procedure Speck_encipher(int data[2], int key[], int rounds)
    local int key_expanded[rounds]
	local int i = 0
    call Speck_key_expansion(key, key_expanded)
    from i = 0 loop
        //todo: this can be replaced with a generic round function, the same as in key expansion
        // (S^-8 x, y)
        uncall rotate_left(data[0], 8)
        // (S^-8 x + y, y)
        data[0] += data[1]
        // ((S^-8 x + y) ^ k, y)
        data[0] ^= key_expanded[i]
        // ((S^-8 x + y) ^ k, S^3 y)
        call rotate_left(data[1], 3)
        // ((S^-8 x + y) ^ k, S^3 y ^ (S^-8 x + y) ^ k)
        data[1] ^= data[0]
        i += 1
    until i = rounds
    uncall Speck_key_expansion(key, key_expanded)
    delocal int i = rounds
    delocal int key_expanded[rounds]


procedure main()
    int key[4]
    int data[2]
    int more_data[4]
    int num_rounds

    key[0] += 0
    key[1] += 1
    key[2] += 2
    key[3] += 3
    
    data[0] += 42
    data[1] += 27
    
    more_data[0] += 42
    more_data[1] += 27
    more_data[2] += 42
    more_data[3] += 27
    
    num_rounds += 32
    
    show(data)
    call Speck_encipher(data, key, num_rounds)
    show(data)
    uncall Speck_encipher(data, key, num_rounds)
    show(data)
